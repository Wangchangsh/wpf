---
title: 高杂合率F1群体的遗传作图
author: wangchangsheng
date: '2022-09-11'
slug: []
categories: 
  - Genetics
tags:
  - genetic map
  - Lep-Map3
---



<div id="前言" class="section level2">
<h2>前言</h2>
<p>植物的分子遗传研究的重要优势在于遗传群体的易得性。通过设计杂交混合不同来源亲本的基因组，自交获得一系列基因型和表型存在分离的作图群体。但生产上不依赖种子繁殖的高等植物基因组上往往具有较高的杂合率，且具有强的自交不亲和性，如土豆和柑橘。一般利用两个高度杂合的双亲杂交，构建杂种一代群体，用于育种和遗传分析。</p>
<p>Lep-Map3是一款新颖免费的遗传作图软件，支持大量标记和个体的遗传图谱构建，尤其是低测序深度的全基因组测序数据。</p>
</div>
<div id="数据准备" class="section level2">
<h2>数据准备</h2>
<div id="系谱" class="section level3">
<h3>系谱</h3>
<p>系谱文件包含样本名及家系等相关信息，以tab为分隔符，示例如：</p>
<table>
<thead>
<tr class="header">
<th>CHR</th>
<th>POS</th>
<th>F</th>
<th>F</th>
<th>F</th>
<th>F</th>
<th>F</th>
<th>F</th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CHR</td>
<td>POS</td>
<td>SYH</td>
<td>ZNX</td>
<td>F1</td>
<td>F10</td>
<td>F101</td>
<td>F103</td>
<td>F104</td>
</tr>
<tr class="even">
<td>CHR</td>
<td>POS</td>
<td>0</td>
<td>0</td>
<td>ZNX</td>
<td>ZNX</td>
<td>ZNX</td>
<td>ZNX</td>
<td>ZNX</td>
</tr>
<tr class="odd">
<td>CHR</td>
<td>POS</td>
<td>0</td>
<td>0</td>
<td>SYH</td>
<td>SYH</td>
<td>SYH</td>
<td>SYH</td>
<td>SYH</td>
</tr>
<tr class="even">
<td>CHR</td>
<td>POS</td>
<td>2</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td>CHR</td>
<td>POS</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>line1：家系名称，可多父母多家系</p>
<p>line2：样本名称</p>
<p>line3：父本名称，对应第二行第四列</p>
<p>line4：母本名称，对应第二行第三列</p>
<p>line5：性别，1为male，2为female，0为unknow</p>
<p>line6：表型，用不到，全为0</p>
</div>
<div id="基因型" class="section level3">
<h3>基因型</h3>
<p>VCF文件，必须包含likelihood信息，使用vcftools注意增加–recode-INFO-all参数。</p>
<p>从GATK的基因型文件，主要处理步骤为</p>
<ul>
<li>提取SNP</li>
<li>GATK硬过滤</li>
<li>Founder多态性变异鉴定</li>
<li>offspring高质量变异鉴定</li>
<li>ParentCall2格式转换</li>
</ul>
<div id="gatk提取snp" class="section level4">
<h4>GATK提取SNP</h4>
<pre class="shell"><code>singularity exec -e ~/Singularity_lib/gatk-4.2.2.0.sif gatk SelectVariants 
-R ~/wpf/Datasets/Reference/Lychee/BWA/Lchinesis_genome.fa 
-V ../07.VCF/raw/pop.vcf.gz 
-O ../07.VCF/variant/pop.snp.vcf.gz 
--select-type-to-include SNP</code></pre>
</div>
<div id="gatk硬过滤" class="section level4">
<h4>GATK硬过滤</h4>
<pre class="shell"><code>singularity exec -e ~/Singularity_lib/gatk-4.2.2.0.sif gatk VariantFiltration 
-R ~/wpf/Datasets/Reference/Lychee/BWA/Lchinesis_genome.fa 
-V ../07.VCF/variant/pop.snp.vcf.gz 
--filter-name &quot;firstFilter&quot; 
--filter-expression &quot;QD &lt; 2.0 || MQ &lt; 40.0 || FS &gt; 60.0 || SOR &gt; 3.0 
|| MQRankSum &lt; -12.5 || ReadPosRankSum &lt; -8.0&quot; 
-O ../07.VCF/gatkvf/pop.snp.filt.vcf.gz</code></pre>
</div>
<div id="founder多态性变异鉴定" class="section level4">
<h4>Founder多态性变异鉴定</h4>
<ul>
<li>初过滤标准为PASS，二等位，无缺失，测序深度为平均测序深度的一半至两倍</li>
</ul>
<pre class="shell"><code>vcftools 
--gzvcf pop.snp.filt.vcf.gz 
--remove-filtered-all 
--indv founder1 
--indv founder2 
--max-alleles 2 
--min-alleles 2 
--max-missing 1 
--max-meanDP 60 
--min-meanDP 15 
--recode 
--out founder</code></pre>
<ul>
<li>多态性具有重组信息的标记筛选，即至少有一个亲本为杂合型</li>
</ul>
<pre class="python"><code>import re 
vcf = open(&#39;founder.recode.vcf&#39;)
output = open(&#39;founder.filter.vcf&#39;,&#39;w&#39;)
for i in vcf:
    try:
        row = re.split(r&#39;\t&#39;,i)
        p1 = re.split(r&#39;\:&#39;,row[9])[0]
        p2 = re.split(r&#39;\:&#39;,row[10])[0]
        if (p1 == &#39;0/1&#39; or p2 == &#39;0/1&#39;):
            output.write(i)
        else:
            continue
    except IndexError:
        output.write(i)
vcf.close()
output.close()</code></pre>
<ul>
<li>高质量位点筛选，SNPable筛选出无重复比对的位点</li>
</ul>
<pre class="shell"><code>awk &#39;{print$1&quot;\t&quot;$2}&#39; founder.filter.vcf |grep -v &quot;#&quot; &gt; founder.pos
apply_mask_l mask_35_50.fa founder.pos &gt; foundermask.pos </code></pre>
</div>
<div id="offspring高质量变异鉴定" class="section level4">
<h4>offspring高质量变异鉴定</h4>
<ul>
<li>初过滤标准为缺失率，maf和founder高质量位点</li>
</ul>
<pre class="shell"><code>vcftools 
--gzvcf pop.snp.filt.vcf.gz 
--max-missing 0.8 
--maf 0.05 
--positions foundermask.pos 
--recode-INFO-all 
--recode 
--out offspring_poly</code></pre>
<ul>
<li>分割染色体，并过滤偏分离标记</li>
</ul>
<pre class="shell"><code>vcftools 
--vcf offspring_poly.recode.vcf 
--chr Chr1 
--recode-INFO-all 
--recode 
--out Chr1</code></pre>
<pre class="r"><code>chisq &lt;- function(x) {
  matrix &lt;- matrix(x, ncol = 2) %&gt;%
    as_tibble() %&gt;%
    filter(if_any(everything(), ~ . != 0))
  return(chisq.test(matrix)$p.value)
}

library(tidyverse)
library(vcfR)


tmp &lt;- read.vcfR(&quot;Lychee/Data/geno/Chr1.recode.vcf&quot;) %&gt;%
  extract.gt() %&gt;%
  as_tibble(rownames = NA) %&gt;%
  rownames_to_column(var = &quot;markername&quot;) %&gt;%
  mutate(A = rowSums(across(.cols = starts_with(&quot;F&quot;), `%in%`, &quot;0/0&quot;)),
         H = rowSums(across(.cols = starts_with(&quot;F&quot;), `%in%`, &quot;0/1&quot;)),
         B = rowSums(across(.cols = starts_with(&quot;F&quot;), `%in%`, &quot;1/1&quot;))) %&gt;%
  select(-starts_with(&quot;F&quot;)) %&gt;%
  mutate(number = A + H + B,
         EA = case_when(
           SYH == &quot;0/1&quot; &amp; ZNX == &quot;0/1&quot; ~ number/4,
           SYH == &quot;0/0&quot; &amp; ZNX == &quot;0/1&quot; ~ number/2,
           SYH == &quot;0/1&quot; &amp; ZNX == &quot;0/0&quot; ~ number/2,
           SYH == &quot;1/1&quot; &amp; ZNX == &quot;0/1&quot; ~ 0,
           SYH == &quot;0/1&quot; &amp; ZNX == &quot;1/1&quot; ~ 0
         ),
         EH = number/2,
         EB = case_when(
           SYH == &quot;0/1&quot; &amp; ZNX == &quot;0/1&quot; ~ number/4,
           SYH == &quot;0/0&quot; &amp; ZNX == &quot;0/1&quot; ~ 0,
           SYH == &quot;0/1&quot; &amp; ZNX == &quot;0/0&quot; ~ 0,
           SYH == &quot;1/1&quot; &amp; ZNX == &quot;0/1&quot; ~ number/2,
           SYH == &quot;0/1&quot; &amp; ZNX == &quot;1/1&quot; ~ number/2
         )) %&gt;%
  rowwise() %&gt;%
  mutate(pval = chisq(c(A, H, B, EA, EH, EB))) %&gt;%
  filter(pval &gt; 0.001) %&gt;%
  mutate(chrom = sapply(str_split(markername, &quot;_&quot;), `[`, 1),
         pos = sapply(str_split(markername, &quot;_&quot;), `[`, 2) %&gt;% as.numeric()) %&gt;%
  select(chrom, pos)
  
write_tsv(tmp, file = &quot;Chr1.pos&quot;, col_names = FALSE)</code></pre>
<pre class="shell"><code>vcftools 
--vcf Chr1.recode.vcf 
--positions Chr1.pos 
--recode-INFO-all 
--recode 
--out Chr1_chisq</code></pre>
</div>
<div id="parentcall2格式转换" class="section level4">
<h4>ParentCall2格式转换</h4>
<p>输入为十进制文件，压缩文件读取出错</p>
<pre class="shell"><code>java -cp ~/software/LepMAP3/bin/ ParentCall2 
data=pedigree.txt 
vcfFile=Chr1_chisq.recode.vcf 
removeNonInformative=1 &gt; Chr1_chisq.call</code></pre>
</div>
</div>
</div>
<div id="无参标记的遗传图谱构建" class="section level2">
<h2>无参标记的遗传图谱构建</h2>
<p>无参考基因组项目没接触过，或许GBS或RADseq可以产生这些标记。标记鉴定的基本思路应该是聚类测序read，组装或不组装生成参考序列（以每一种read为独立的参考序列）并鉴定标记，这些标记没有确切的坐标，通过后代的分离重组情况，重建遗传连锁图，确定标记间的相对位置。</p>
<p>基本流程为</p>
<ul>
<li>SeparateChromosomes2标记分群</li>
<li>JoinSingles2All单独标记插补进连锁群</li>
<li>OrderMarkers2标记排序，计算遗传距离</li>
</ul>
<div id="分群" class="section level3">
<h3>分群</h3>
<pre class="shell"><code>java -cp ~/software/LepMAP3/bin/ SeparateChromosomes2 
data=Chr1_chisq.call 
lodLimit=5 
numThreads=8 
distortionLod=1 &gt; Chr1_chisq.map</code></pre>
</div>
<div id="插补" class="section level3">
<h3>插补</h3>
<pre class="shell"><code>java -cp ~/software/LepMAP3/bin/ JoinSingles2All 
map=Chr1_chisq.map 
data=Chr1_chisq.call  
distortionLod=1 
numThreads=8 
lodLimit=4 
iterate=1 &gt; Chr1_chisq_js_iterated.map</code></pre>
</div>
<div id="排序" class="section level3">
<h3>排序</h3>
<pre class="shell"><code>java -cp ~/software/LepMAP3/bin/ OrderMarkers2 
numThreads=20 
map=Chr1_chisq_js_iterated.map 
data=Chr1_chisq.call &gt; Chr1_chisq.order</code></pre>
</div>
<div id="计算遗传距离" class="section level3">
<h3>计算遗传距离</h3>
<pre class="shell"><code>java -cp ~/software/LepMAP3/bin/ OrderMarkers2 
evaluateOrder=Chr1_chisq.order 
data=Chr1_chisq.call 
improveOrder=0 
sexAveraged=1 &gt; Chr1_chisq_sexAve.order

java -cp ~/software/LepMAP3/bin/ OrderMarkers2 
evaluateOrder=Chr1_chisq.order 
data=Chr1_chisq.call 
improveOrder=0 &gt; Chr1_chisq_sex.order</code></pre>
</div>
</div>
<div id="有参标记的遗传图谱构建" class="section level2">
<h2>有参标记的遗传图谱构建</h2>
<p>有参考基因组的标记无需分群排序，按照物理位置的顺序直接计算重组距离。</p>
<p>标记数量过多，以10kb为window构建遗传连锁图，主要流程为</p>
<ul>
<li>构建10kb binning图谱</li>
<li>OrderMarkers2排序</li>
<li>提取window代表基因型</li>
<li>OrderMarkers2计算遗传距离</li>
</ul>
<div id="binning" class="section level3">
<h3>binning</h3>
<pre class="shell"><code>awk &#39;BEGIN{print &quot;#binned markers&quot;}(NR&gt;7)
{if (prevc != $1 || $2-prevp &gt;= 10000) {++n;prevp=$2;prevc=$1}; print n}&#39; 
Chr1_chisq.call &gt; Chr1_chisq.map</code></pre>
</div>
<div id="排序-1" class="section level3">
<h3>排序</h3>
<pre class="shell"><code>java -cp ~/software/LepMAP3/bin/ OrderMarkers2 
numThreads=20 
map=Chr1_chisq.map 
data=Chr1_chisq.call 
recombination1=0 
recombination2=0 
outputPhasedData=4 &gt; Chr1_chisq.order</code></pre>
</div>
<div id="提取标记" class="section level3">
<h3>提取标记</h3>
<p>利用脚本order2data.awk提取binning标记</p>
<pre class="awk"><code>#script for marker binning...
BEGIN{
#ACxAG=AA,AC,AG,CG
        map[&quot;AA&quot;] = &quot;1 0 0 0 0 0 0&quot;#00
        map[&quot;AC&quot;] = &quot;0 1 0 0 0 0 0&quot;#01
        map[&quot;AG&quot;] = &quot;0 0 1 0 0 0 0&quot;#10
        map[&quot;CG&quot;] = &quot;0 0 0 0 0 1 0&quot;#11

        if (chr == &quot;&quot;)
                 chr = 1
}
/^[^#]/{
        for (j = 7; j &lt;= NF; ++j)
                if ($j ~ /#$/) {
                        $j = substr($j, 1, length($j) - 1)
                        oldNF = j
                        break
                }
        if (oldNF == NF)
                next
        if (prev == &quot;&quot; &amp;&amp; pedigree) {
                s1 = &quot;CHR\tPOS&quot;
                s2 = &quot;CHR\tPOS&quot;
                s3 = &quot;CHR\tPOS&quot;
                s4 = &quot;CHR\tPOS&quot;
                s5 = &quot;CHR\tPOS&quot;
                s6 = &quot;CHR\tPOS&quot;
                f = 1
                nt = 0
                for (j = 7; j &lt;= oldNF; j+=3) {
                        n = length($j) / 2
                        s1 = s1 &quot;\tF&quot; f &quot;\tF&quot; f
                        s2 = s2 &quot;\t&quot; (nt + 1) &quot;\t&quot; (nt + 2)
                        s3 = s3 &quot;\t0\t0&quot;
                        s4 = s4 &quot;\t0\t0&quot;
                        s5 = s5 &quot;\t1\t2&quot;
                        s6 = s6 &quot;\t0\t0&quot;
                        for (i = 1; i &lt;= n; ++i) {
                                s1 = s1 &quot;\tF&quot; f
                                s2 = s2 &quot;\t&quot; (nt + i + 2)
                                s3 = s3 &quot;\t&quot; (nt + 1)
                                s4 = s4 &quot;\t&quot; (nt + 2)
                                s5 = s5 &quot;\t0&quot;
                                s6 = s6 &quot;\t0&quot;
                        }
                        nt += n + 2
                        ++f
                }
                print s1 &quot;\n&quot; s2 &quot;\n&quot; s3 &quot;\n&quot; s4 &quot;\n&quot; s5 &quot;\n&quot; s6 
        }

        s = &quot;&quot;
        nt = 0
        for (j = 7; j &lt;= oldNF; j+=3) {
                s = s &quot;\t&quot; map[&quot;AC&quot;] &quot;\t&quot; map[&quot;AG&quot;]
                n = length($j) / 2
                for (i = oldNF + nt + 1; i &lt;= oldNF + nt + 4 *n; i+=4)
                        s = s &quot;\t&quot; $i &quot; &quot; $(i+1) &quot; &quot; $(i+2) &quot; 0 0 &quot; $(i+3) &quot; 0&quot;
                nt += 4 * n
        }
        if (prev != s || FILENAME != prevFN)
                print $1 &quot;\t&quot; chr s
        prev = s
        prevFN = FILENAME
}</code></pre>
<pre class="shell"><code>awk -vfunnData=1 -f order2data.awk ../02.Orderraw/Chr1_chisq.order |
awk &#39;{print$1}&#39; &gt; Chr1_chisq.index

awk &#39;{print$1&quot;\t&quot;$2}&#39; Chr1_chisq.call |grep Chr1 &gt; Chr1_chisq.pos</code></pre>
<pre class="r"><code>library(tidyverse)

pos &lt;- read_tsv(&quot;Chr1_chisq.pos&quot;, col_names = FALSE) %&gt;%
  mutate(id = row_number()) 

index &lt;- read_tsv(&quot;Chr1_chisq.index&quot;, col_names = FALSE) %&gt;%
  rename(id = X1) 

tmp &lt;- index %&gt;%
  left_join(pos, by = &quot;id&quot;) %&gt;%
  select(-id)

write_tsv(tmp, file = &quot;Chr1_chisq_bin.pos&quot;, col_names = FALSE)</code></pre>
<pre class="shell"><code>vcftools 
--vcf Chr1_chisq.recode.vcf 
--positions Chr1_chisq_bin.pos 
--recode 
--recode-INFO-all 
--out Chr1_chisq_bin

java -cp ~/software/LepMAP3/bin/ ParentCall2 
data=pedigree.txt 
vcfFile=Chr1_chisq_bin.recode.vcf &gt; Chr1_chisq_bin.call</code></pre>
</div>
<div id="计算遗传距离-1" class="section level3">
<h3>计算遗传距离</h3>
<pre class="shell"><code>awk &#39;{print NR}&#39; Chr1_chisq_bin.pos &gt; Chr1_chisq_bin.order

java -cp ~/software/LepMAP3/bin/ OrderMarkers2 
evaluateOrder=Chr1_chisq.order 
data=Chr1_chisq.call 
improveOrder=0 
sexAveraged=1 &gt; Chr1_chisq_sexAve.order

java -cp ~/software/LepMAP3/bin/ OrderMarkers2 
evaluateOrder=Chr1_chisq.order 
data=Chr1_chisq.call 
improveOrder=0 &gt; Chr1_chisq_sex.order</code></pre>
</div>
</div>
<div id="转换基因型" class="section level2">
<h2>转换基因型</h2>
<p>利用脚本map2genotypes.awk转换基因型。</p>
<pre class="awk"><code>#converts phased data to &quot;genotypes&quot;
#usage: 
#java ... OrderMarkers2 ... outputPhasedData=1 &gt; order_with_phase_LM3.txt
#awk [-vchr=X] [-vfullData=1] -f map2genotypes.awk order_with_phase_LM3.txt
#output columns marker name, chr, male postion, female postion, genotypes coded as &quot;1 1&quot;, &quot;1 2&quot;, &quot;2 2&quot; and 0 as missing
#providing fullData ouputs parents and pedigree...
BEGIN{
        map[&quot;00&quot;]=&quot;1 1&quot;
        map[&quot;01&quot;]=&quot;1 2&quot;
        map[&quot;10&quot;]=&quot;2 1&quot;
        map[&quot;11&quot;]=&quot;2 2&quot;
        map[&quot;0-&quot;]=&quot;1 0&quot;
        map[&quot;-0&quot;]=&quot;0 1&quot;
        map[&quot;-1&quot;]=&quot;0 2&quot;
        map[&quot;1-&quot;]=&quot;2 0&quot;
        map[&quot;--&quot;]=&quot;0 0&quot;
        if (chr == &quot;&quot;)
                chr = 0
}
(/^[^#]/){
        if (!notFirst &amp;&amp; fullData){
                notFirst = 1
                s1 =  &quot;MARKER\tCHR\tMALE_POS\tFEMALE_POS&quot;
                s2 =  &quot;MARKER\tCHR\tMALE_POS\tFEMALE_POS&quot;
                s3 =  &quot;MARKER\tCHR\tMALE_POS\tFEMALE_POS&quot;
                s4 =  &quot;MARKER\tCHR\tMALE_POS\tFEMALE_POS&quot;
                s5 =  &quot;MARKER\tCHR\tMALE_POS\tFEMALE_POS&quot;
                s6 =  &quot;MARKER\tCHR\tMALE_POS\tFEMALE_POS&quot;
                for (i = 7; i&lt;=NF; i+=3) {
                        n = length($i) / 2
                        p1 = &quot;P&quot; (++numParents)
                        p2 = &quot;P&quot; (++numParents)
                        s1 = s1 &quot;\t&quot; p1 &quot;x&quot; p2 &quot;\t&quot; p1 &quot;x&quot; p2
                        s2 = s2 &quot;\t&quot; p1 &quot;\t&quot; p2
                        s3 = s3 &quot;\t&quot; 0 &quot;\t&quot; 0
                        s4 = s4 &quot;\t&quot; 0 &quot;\t&quot; 0
                        s5 = s5 &quot;\t&quot; 1 &quot;\t&quot; 2
                        s6 = s6 &quot;\t&quot; 0 &quot;\t&quot; 0
                        for (j = 1; j &lt;= n; ++j) {
                                s1 = s1 &quot;\t&quot; p1 &quot;x&quot; p2
                                s2 = s2 &quot;\tC&quot; (++numOffspring)
                                s3 = s3 &quot;\t&quot; p1
                                s4 = s4 &quot;\t&quot; p2
                                s5 = s5 &quot;\t0&quot; 
                                s6 = s6 &quot;\t0&quot; 
                        }
                }
                print s1
                print s2
                print s3
                print s4
                print s5
                print s6
        }
        s = $1 &quot;\t&quot; chr &quot;\t&quot; $2 &quot;\t&quot; $3
        for (i = 7; i&lt;=NF; i+=3) {
                if (fullData) #parental data
                        s = s &quot;\t1 2\t1 2&quot;
                n = length($i) / 2
                p1 = substr($i,1,n)
                p2 = substr($i,n+1)
                for (j = 1; j &lt;= n; ++j)
                        s = s &quot;\t&quot; map[substr(p1, j, 1) substr(p2, j, 1)]
        }
        print s
}</code></pre>
<pre class="shell"><code>awk -vfullData=1 -f map2genotypes.awk Chr1_chisq_sex.order &gt; 
Chr1_chisq_sex.geno

awk -vfullData=1 -f map2genotypes.awk Chr1_chisq_Avesex.order &gt; 
Chr1_chisq_sexAve.geno</code></pre>
</div>
<div id="作图" class="section level2">
<h2>作图</h2>
<p>利用R/qtl包作图</p>
<pre class="r"><code>library(tidyverse)
library(qtl)

file &lt;- fs::dir_ls(path = &quot;Lychee/Data/geno/&quot;, glob = &quot;*Ave*&quot;)

tmp &lt;- map_dfr(.x = file,
               .f = ~ read_tsv(., skip = 1, col_select = c(1:4)),
               .id = &quot;Chrtmp&quot;)

tmp2 &lt;- tmp %&gt;%
  filter(MARKER != &quot;MARKER&quot;) %&gt;%
  mutate(chrom = sapply(str_split(Chrtmp, &quot;/|_&quot;), `[`, 4),
         markername = str_c(chrom, &quot;-&quot;, MARKER),
         chr = str_sub(chrom, 4) %&gt;% as.numeric(),
         pos = as.numeric(MALE_POS)) %&gt;%
  select(markername, chr, pos) %&gt;%
  arrange(chr) %&gt;%
  column_to_rownames(var = &quot;markername&quot;)

map &lt;- table2map(tmp2)
plot.map(map)</code></pre>
<p><img src="https://cdn.staticaly.com/gh/Wangchangsh/image@main/F1mapping/map.kxnr73qryuo.webp" /></p>
</div>
